package leetcodepractice.leetcode;

/**
 * @author dimmy
 */
public class maxMatrixSum__1975 {

    //给你一个 n x n 的整数方阵 matrix 。你可以执行以下操作 任意次 ：
    //选择 matrix 中 相邻 两个元素，并将它们都 乘以 -1 。
    //如果两个元素有 公共边 ，那么它们就是 相邻 的。
    //你的目的是 最大化 方阵元素的和。请你在执行以上操作之后，返回方阵的 最大 和。

    /**
     * 为了使得操作后方阵总和最大，我们需要使得负数元素的总和尽可能大。
     * 对于方阵中的两个负数元素，一定存在一系列的操作使得这两个负数元素均变为正数，且其余元素不变。
     * 对于方阵中的一个正数元素和一个负数元素，一定存在一系列的操作使得这两个元素交换正负，且其余元素不变。
     * <p>
     * 提示 1 解释
     * <p>
     * 第一部分是显然的。
     * <p>
     * 对于第二部分，我们可以任意选择一条连接两个负数元素的有向路径，按顺序对路径上（除终点以外）的每个元素和它对应的下一个元素都执行一次操作。最终路径上除了两个端点以外的其他元素都被执行了两次操作，因此数值不变；两个端点元素都被执行了一次操作二变为正数。
     * <p>
     * 由于方阵是网格，因此上述路径一定存在。
     * <p>
     * 对于第三部分，将第二部分中的一个负数更改为正数即可证明。
     * <p>
     * 如果方阵中存在一个元素为 0，另一个元素为负数。那么一定存在一系列的操作使得负数元素变为正数，且其余元素不变。
     * <p>
     * 提示 2 解释
     * <p>
     * 类似 提示 1，将一个负数元素更改为 0 即可证明。
     * <p>
     * 提示 3
     * <p>
     * 如果方阵中存在 0，那么一定可以通过一系列的操作使得方阵中所有元素均为非负数;
     * <p>
     * 如果方阵中不存在 0，那么：
     * <p>
     * 如果方阵中有奇数个负数元素，那么一定可以通过一系列的操作使得方阵中只有一个负数元素，且该负数元素可以在任何位置。同时，无论如何操作，方阵中必定存在负数元素。
     * <p>
     * 如果方阵中有偶数个负数元素，那么一定可以通过一系列的操作使得方阵中不存在负数元素。
     * <p>
     * 提示 3 解释
     * <p>
     * 对于第一部分，反复对 0 和负数元素进行 提示 2 的操作即可。
     * <p>
     * 对于第二部分，我们首先可以证明如果方阵不存在 0，那么负数元素数量的奇偶性不会改变。然后，我们可以根据 提示 1 构造出一系列操作从而达到对应的要求。
     * <p>
     * 思路与算法
     * <p>
     * 根据 提示 3，我们可以按照方阵的元素分为以下几种情况：
     * <p>
     * 方阵中有 0，那么最大方阵和即为所有元素的绝对值之和；
     * <p>
     * 方阵中没有 0，且负数元素数量为偶数，那么最大方阵和即为所有元素的绝对值之和；
     * <p>
     * 方阵中没有 0，且负数元素数量为奇数，那么最大方阵和即为所有元素的绝对值之和减去所有元素最小绝对值的两倍。
     * <p>
     * 其中，第一种情况也可以按照负数元素数量的奇偶性划入后两种情况中（此时最小绝对值一定为 0）。
     * <p>
     * 我们遍历方阵，维护负数元素的数量、元素的最小绝对值以及所有元素的绝对值之和。随后，我们按照负数元素数量的奇偶性计算对应的最大元素和并返回。
     * <p>
     * 最后，矩阵所有元素绝对值之和可能超过 32 位整数的上限，因此对于 C++ 等语言，需要使用 64 位整数来维护。
     * <p>
     * 作者：力扣官方题解
     * 链接：https://leetcode.cn/problems/maximum-matrix-sum/solutions/951896/zui-da-fang-zhen-he-by-leetcode-solution-5xnx/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     *
     * @param matrix
     * @return 36
     * [[2,9,3],[5,4,-4],[1,7,1]]
     * 输出
     * 28
     * 预期结果
     * 34
     */
    public long maxMatrixSum(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int negativeCount = 0;
        boolean hasZero = false;
        long total = 0;
        long min = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] < 0) negativeCount++;
                else if (matrix[i][j] == 0) hasZero = true;
                var abs = Math.abs(matrix[i][j]);
                total += abs;
                min = Math.min(min, abs);
            }
        }

        if (hasZero || negativeCount % 2 == 0) return total;
        return total - 2L * Math.abs(min);
    }
}
