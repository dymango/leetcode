package leetcodepractice.leetcode;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

/**
 * @author dimmy
 */
public class MinMalwareSpread_924 {

    /**
     * 给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j。 
     * <p>
     * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
     * <p>
     * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
     * <p>
     * 如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
     * <p>
     * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染。
     * <p>
     *  
     * <p>
     * 示例 1：
     * <p>
     * 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
     * 输出：0
     * 示例 2：
     * <p>
     * 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
     * 输出：0
     * 示例 3：
     * <p>
     * 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
     * 输出：1
     *  
     * <p>
     * 提示：
     * <p>
     * n == graph.length
     * n == graph[i].length
     * 2 <= n <= 300
     * graph[i][j] == 0 或 1.
     * graph[i][j] == graph[j][i]
     * graph[i][i] == 1
     * 1 <= initial.length <= n
     * 0 <= initial[i] <= n - 1
     * initial 中所有整数均不重复
     * <p>
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode.cn/problems/minimize-malware-spread
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     *
     * @param graph
     * @param initial
     * @return
     */
    //[[1,1,0],
    // [1,1,0],
    // [0,0,1]]
    //[0,1,2]

    //[[1,1,0],[1,1,0],[0,0,1]]
    //[0,1,2]

    //[[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,1,1]]
    //[3,1]

    //[[1,1,0],[1,1,0],[0,0,1]]
    //[0,1,2]

    //[[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,1,1]]
    //[3,1]
    public static void main(String[] args) {
        //[[1,0,0,0,1,0,0,0,0,0,1],[0,1,0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,1,0,0,0],[0,1,0,1,0,1,0,0,0,0,0],[1,0,0,0,1,0,0,0,0,0,0],[0,0,0,1,0,1,0,0,1,1,0],[0,0,0,0,0,0,1,1,0,0,0],[0,0,1,0,0,0,1,1,0,0,0],[0,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0],[1,0,0,0,0,0,0,0,0,0,1]]
        //[7,8,6,2,3]
        System.out.println(new MinMalwareSpread_924().minMalwareSpread(new int[][]{{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 1}, {0, 0, 1, 1}}, new int[]{3, 1}));
    }

    int size;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        Map<Integer, Set<Integer>> connectNodeMap = new HashMap<>();
        int row = graph.length;
        int column = graph[0].length;
        size = row;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                if (!connectNodeMap.containsKey(i)) connectNodeMap.put(i, new HashSet<>());
                if (!connectNodeMap.containsKey(j)) connectNodeMap.put(j, new HashSet<>());
                if (graph[i][j] == 1) {
                    connectNodeMap.get(i).add(j);
                    connectNodeMap.get(j).add(i);
                }

            }
        }

        int initRemain = calculateRemain(initial, connectNodeMap, null);
        int resultNode = Integer.MAX_VALUE;
        int remain = Integer.MIN_VALUE;
        for (int init : initial) {
            Set<Integer> infectNodeSet = new HashSet<>();
            for (int i : initial) {
                if (init == i) continue;
                infectNodeSet.add(i);
            }

            boolean find = isInfect(connectNodeMap, infectNodeSet, init);
            if (find) {
                if (initRemain == remain) {
                    if (init < resultNode) {
                        resultNode = init;
                    }
                } else if (initRemain > remain) {
                    remain = initRemain;
                    resultNode = init;
                }
                continue;
            }
            int remainExcludeI = calculateRemain(initial, connectNodeMap, init);
            if (remainExcludeI == remain) {
                if (init < resultNode) {
                    resultNode = init;
                }
            } else if (remainExcludeI > remain) {
                remain = remainExcludeI;
                resultNode = init;
            }
        }

        return resultNode == Integer.MAX_VALUE ? initial[0] : resultNode;
    }

    private int calculateRemain(int[] initial, Map<Integer, Set<Integer>> connectNodeMap, Integer exclude) {
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        for (int i : initial) {
            if (exclude != null && i == exclude) continue;
            queue.add(i);
            visited.add(i);
        }

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Integer poll = queue.poll();
                Set<Integer> connectNodes = connectNodeMap.get(poll);
                if (connectNodes != null) {
                    for (Integer connectNode : connectNodes) {
                        if (visited.add(connectNode)) {
                            queue.add(connectNode);
                            visited.add(connectNode);
                        }
                    }
                }
            }
        }

        return size - visited.size();
    }

    private boolean isInfect(Map<Integer, Set<Integer>> connectNodeMap, Set<Integer> infectNodeSet, int i) {
        boolean find = false;
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        queue.add(i);
        visited.add(i);
        tag:
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int s = 0; s < size; s++) {
                Integer poll = queue.poll();
                Set<Integer> connectNodes = connectNodeMap.get(poll);
                if (connectNodes != null) {
                    for (Integer connectNode : connectNodes) {
                        if (visited.add(connectNode)) {
                            if (infectNodeSet.contains(connectNode)) {
                                find = true;
                                break tag;
                            }

                            queue.add(connectNode);
                            visited.add(connectNode);
                        }
                    }
                }
            }
        }
        return find;
    }

    public int minMalwareSpreadV2(int[][] graph, int[] initial) {
        int row = graph.length;
        int col = graph[0].length;
        DSU dsu = new DSU(row);
        for (int i = 0; i < row; i++) {
            for (int j = i + 1; j < col; j++) {
                if (graph[i][j] == 1) dsu.union(i, j);
            }
        }

        int ans = -1, ansSize = -1;
        //统计有几块连通分量
        int[] count = new int[row];
        for (int i : initial) {
            count[dsu.find(i)]++;
        }

        for (int i : initial) {
            int ip = dsu.find(i);
            if (count[ip] == 1) {
                int size = dsu.size(ip);
                if (size > ansSize) {
                    ans = i;
                    ansSize = size;
                } else if (size == ansSize && i < ans) {
                    ans = i;
                }
            }
        }

        if (ans == -1) {
            ans = Integer.MAX_VALUE;
            for (int node : initial) {
                ans = Math.min(ans, node);
            }
        }

        return ans;
    }


    public class DSU {
        public int[] id;
        public int[] count;

        DSU(int N) {
            id = new int[N];
            for (int x = 0; x < N; ++x)
                id[x] = x;

            count = new int[N];
            Arrays.fill(count, 1);
        }

        public int find(int x) {
            if (id[x] != x) {
                id[x] = find(id[x]);
            }

            return id[x];
        }

        public void union(int x, int y) {
            int xp = find(x);
            int yp = find(y);
            if (xp == yp) return;
            id[xp] = yp;
            count[yp] += count[xp];
        }

        public int size(int x) {
            return count[find(x)];
        }
    }
}
