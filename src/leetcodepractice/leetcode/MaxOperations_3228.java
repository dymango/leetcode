package leetcodepractice.leetcode;

/**
 * @author dimmy
 */
public class MaxOperations_3228 {
    /**
     * 给你一个 二进制字符串 s。
     * 你可以对这个字符串执行 任意次 下述操作：
     * 选择字符串中的任一下标 i（ i + 1 < s.length ），该下标满足 s[i] == '1' 且 s[i + 1] == '0'。
     * 将字符 s[i] 向 右移 直到它到达字符串的末端或另一个 '1'。例如，对于 s = "010010"，如果我们选择 i = 1，结果字符串将会是 s = "000110"。
     * 返回你能执行的 最大 操作次数。
     * <p>
     * <p>
     * 示例 1：
     * 输入： s = "1001101"
     * 输出： 4
     * <p>
     * 解释：
     * 可以执行以下操作：
     * 选择下标 i = 0。结果字符串为 s = "0011101"。
     * 选择下标 i = 4。结果字符串为 s = "0011011"。
     * 选择下标 i = 3。结果字符串为 s = "0010111"。
     * 选择下标 i = 2。结果字符串为 s = "0001111"。
     *
     * @param s
     * @return
     */
    int[] memory;

    public static void main(String[] args) {
        System.out.println(new MaxOperations_3228().maxOperations("00111"));
    }

    public int maxOperations(String s) {
        memory = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == '1') {
                count(i, s);
                break;
            }
        }

        var sum = 0;
        for (int i : memory) {
            sum += i;
        }

        return sum;
    }

    private int count(int index, String s) {
        if (index >= s.length() - 1) return 0;
        char nextChar = s.charAt(index + 1);
        if (nextChar == '0') {
            int i = index + 1;
            while (i < s.length() && s.charAt(i) == '0') {
                i++;
            }

            var count =  1 + count(i, s);
            memory[index] = count;
            return count;
        } else {
            var count = count(index + 1, s);
            memory[index] = count;
            return count;
        }
    }

}
